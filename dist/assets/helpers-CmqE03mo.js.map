{"version":3,"file":"helpers-CmqE03mo.js","sources":["../../src/utils/helpers.ts"],"sourcesContent":["/**\n * Common utility functions\n */\n\n/**\n * Debounce function execution\n */\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n  \n  return function executedFunction(...args: Parameters<T>) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    \n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n/**\n * Throttle function execution\n */\nexport function throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle: boolean;\n  \n  return function(this: any, ...args: Parameters<T>) {\n    if (!inThrottle) {\n      func.apply(this, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\n/**\n * Retry async function with exponential backoff\n */\nexport async function retry<T>(\n  fn: () => Promise<T>,\n  options: {\n    maxAttempts?: number;\n    delay?: number;\n    backoff?: number;\n    onRetry?: (attempt: number, error: Error) => void;\n  } = {}\n): Promise<T> {\n  const {\n    maxAttempts = 3,\n    delay = 1000,\n    backoff = 2,\n    onRetry\n  } = options;\n\n  let lastError: Error;\n\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error as Error;\n      \n      if (attempt === maxAttempts) {\n        throw lastError;\n      }\n\n      const waitTime = delay * Math.pow(backoff, attempt - 1);\n      \n      if (onRetry) {\n        onRetry(attempt, lastError);\n      }\n\n      await new Promise(resolve => setTimeout(resolve, waitTime));\n    }\n  }\n\n  throw lastError!;\n}\n\n/**\n * Batch array into chunks\n */\nexport function chunk<T>(array: T[], size: number): T[][] {\n  const chunks: T[][] = [];\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n/**\n * Deep clone object\n */\nexport function deepClone<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (obj instanceof Date) return new Date(obj.getTime()) as any;\n  if (obj instanceof Array) return obj.map(item => deepClone(item)) as any;\n  \n  const clonedObj = {} as T;\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      clonedObj[key] = deepClone(obj[key]);\n    }\n  }\n  return clonedObj;\n}\n\n/**\n * Format file size\n */\nexport function formatFileSize(bytes: number): string {\n  if (bytes === 0) return '0 Bytes';\n\n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\n\n/**\n * Generate unique ID\n */\nexport function generateId(prefix: string = ''): string {\n  const timestamp = Date.now().toString(36);\n  const randomStr = Math.random().toString(36).substr(2, 9);\n  return prefix ? `${prefix}-${timestamp}-${randomStr}` : `${timestamp}-${randomStr}`;\n}\n\n/**\n * Safe JSON parse\n */\nexport function safeJsonParse<T = any>(json: string, defaultValue: T): T {\n  try {\n    return JSON.parse(json);\n  } catch {\n    return defaultValue;\n  }\n}\n\n/**\n * Check if running on server\n */\nexport const isServer = typeof window === 'undefined';\n\n/**\n * Check if running on client\n */\nexport const isClient = !isServer;\n\n/**\n * Format phone number\n */\nexport function formatPhoneNumber(phone: string): string {\n  const cleaned = phone.replace(/\\D/g, '');\n  \n  if (cleaned.length === 11) {\n    return cleaned.replace(/(\\d{3})(\\d{4})(\\d{4})/, '$1-$2-$3');\n  } else if (cleaned.length === 10) {\n    return cleaned.replace(/(\\d{3})(\\d{3})(\\d{4})/, '$1-$2-$3');\n  }\n  \n  return phone;\n}\n\n/**\n * Validate email\n */\nexport function isValidEmail(email: string): boolean {\n  const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return re.test(email);\n}\n\n/**\n * Truncate text\n */\nexport function truncate(text: string, maxLength: number, suffix: string = '...'): string {\n  if (text.length <= maxLength) return text;\n  return text.substring(0, maxLength - suffix.length) + suffix;\n}\n\n/**\n * Remove duplicates from array\n */\nexport function uniqueBy<T, K extends keyof T>(array: T[], key: K): T[] {\n  const seen = new Set();\n  return array.filter(item => {\n    const k = item[key];\n    return seen.has(k) ? false : seen.add(k);\n  });\n}\n\n/**\n * Group array by key\n */\nexport function groupBy<T, K extends keyof T>(array: T[], key: K): Record<string, T[]> {\n  return array.reduce((groups, item) => {\n    const group = String(item[key]);\n    if (!groups[group]) {\n      groups[group] = [];\n    }\n    groups[group].push(item);\n    return groups;\n  }, {} as Record<string, T[]>);\n}\n\n/**\n * Sort array by multiple keys\n */\nexport function sortBy<T>(\n  array: T[],\n  keys: Array<{ key: keyof T; order: 'asc' | 'desc' }>\n): T[] {\n  return [...array].sort((a, b) => {\n    for (const { key, order } of keys) {\n      if (a[key] < b[key]) return order === 'asc' ? -1 : 1;\n      if (a[key] > b[key]) return order === 'asc' ? 1 : -1;\n    }\n    return 0;\n  });\n}\n\n/**\n * 날짜 문자열을 한국어 형식으로 포맷팅합니다.\n * @param dateStr - 변환할 날짜 문자열\n * @returns 포맷된 날짜 문자열 (YYYY.MM.DD 형식)\n */\nexport function formatDate(dateStr?: string | null): string {\n  if (!dateStr) return '-';\n  \n  try {\n    const date = new Date(dateStr);\n    if (isNaN(date.getTime())) return '-';\n    \n    return date.toLocaleDateString('ko-KR', {\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n    });\n  } catch {\n    return '-';\n  }\n}\n\n/**\n * Format date and time for Korean locale\n */\nexport function formatDateTime(dateStr?: string | null): string {\n  if (!dateStr) return '-';\n  \n  try {\n    const date = new Date(dateStr);\n    if (isNaN(date.getTime())) return '-';\n    \n    return date.toLocaleString('ko-KR');\n  } catch {\n    return '-';\n  }\n}\n\n/**\n * Format date as MM-DD format\n */\nexport function formatDateShort(dateStr?: string | null): string {\n  if (!dateStr) return '-';\n  \n  try {\n    const date = new Date(dateStr);\n    if (isNaN(date.getTime())) return '-';\n    \n    return `${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;\n  } catch {\n    return '-';\n  }\n}\n\n/**\n * Format date as ISO format (YYYY-MM-DD)\n */\nexport function formatDateISO(dateStr?: string | null): string {\n  if (!dateStr) return '';\n  \n  try {\n    const date = new Date(dateStr);\n    if (isNaN(date.getTime())) return dateStr || '';\n    \n    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;\n  } catch {\n    return dateStr || '';\n  }\n}\n\n/**\n * Calculate relative time (e.g., \"2시간 전\", \"3일 전\")\n */\nexport function formatRelativeTime(dateStr?: string | null): string {\n  if (!dateStr) return '-';\n  \n  try {\n    const date = new Date(dateStr);\n    const now = new Date();\n    const diffMs = now.getTime() - date.getTime();\n    \n    const diffMinutes = Math.floor(diffMs / (1000 * 60));\n    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));\n    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));\n    \n    if (diffMinutes < 60) {\n      return diffMinutes < 1 ? '방금 전' : `${diffMinutes}분 전`;\n    } else if (diffHours < 24) {\n      return `${diffHours}시간 전`;\n    } else if (diffDays < 7) {\n      return `${diffDays}일 전`;\n    } else {\n      return formatDate(dateStr);\n    }\n  } catch {\n    return '-';\n  }\n}\n\n/**\n * 로컬 날짜를 UTC 자정으로 변환하여 ISO 문자열로 반환\n * 타임존 문제를 방지하기 위해 사용자가 선택한 날짜의 연/월/일만 사용\n * @param date - 변환할 Date 객체\n * @returns UTC 자정으로 변환된 ISO 문자열 (예: \"2024-12-24T00:00:00.000Z\")\n */\nexport function dateToISOString(date: Date): string {\n  const year = date.getFullYear();\n  const month = date.getMonth();\n  const day = date.getDate();\n  const utcDate = new Date(Date.UTC(year, month, day));\n  return utcDate.toISOString();\n}"],"names":["formatFileSize","bytes","i","Math","floor","log","parseFloat","pow","toFixed","formatDate","dateStr","date","Date","isNaN","getTime","toLocaleDateString","year","month","day","formatDateShort","String","getMonth","padStart","getDate","formatDateISO","getFullYear","dateToISOString","UTC","toISOString"],"mappings":"AAqHO,SAASA,EAAeC,GAC7B,GAAc,IAAVA,EAAa,MAAO,UAExB,MAEMC,EAAIC,KAAKC,MAAMD,KAAKE,IAAIJ,GAASE,KAAKE,IAFlC,OAIV,OAAOC,YAAYL,EAAQE,KAAKI,IAJtB,KAI6BL,IAAIM,QAAQ,IAAM,IAH3C,CAAC,QAAS,KAAM,KAAM,KAAM,MAG2BN,EACvE,CA6GO,SAASO,EAAWC,GACzB,IAAKA,EAAS,MAAO,IAErB,IACE,MAAMC,EAAO,IAAIC,KAAKF,GACtB,OAAIG,MAAMF,EAAKG,WAAmB,IAE3BH,EAAKI,mBAAmB,QAAS,CACtCC,KAAM,UACNC,MAAO,UACPC,IAAK,WAET,CAAA,MACE,MAAO,GACT,CACF,CAqBO,SAASC,EAAgBT,GAC9B,IAAKA,EAAS,MAAO,IAErB,IACE,MAAMC,EAAO,IAAIC,KAAKF,GACtB,OAAIG,MAAMF,EAAKG,WAAmB,IAE3B,GAAGM,OAAOT,EAAKU,WAAa,GAAGC,SAAS,EAAG,QAAQF,OAAOT,EAAKY,WAAWD,SAAS,EAAG,MAC/F,CAAA,MACE,MAAO,GACT,CACF,CAKO,SAASE,EAAcd,GAC5B,IAAKA,EAAS,MAAO,GAErB,IACE,MAAMC,EAAO,IAAIC,KAAKF,GACtB,OAAIG,MAAMF,EAAKG,WAAmBJ,GAAW,GAEtC,GAAGC,EAAKc,iBAAiBL,OAAOT,EAAKU,WAAa,GAAGC,SAAS,EAAG,QAAQF,OAAOT,EAAKY,WAAWD,SAAS,EAAG,MACrH,CAAA,MACE,OAAOZ,GAAW,EACpB,CACF,CAqCO,SAASgB,EAAgBf,GAC9B,MAAMK,EAAOL,EAAKc,cACZR,EAAQN,EAAKU,WACbH,EAAMP,EAAKY,UAEjB,OADgB,IAAIX,KAAKA,KAAKe,IAAIX,EAAMC,EAAOC,IAChCU,aACjB"}
{"version":3,"file":"helpers-BMiTuHMe.js","sources":["../../src/utils/helpers.ts"],"sourcesContent":["/**\n * Common utility functions\n */\n\n/**\n * Debounce function execution\n */\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n  \n  return function executedFunction(...args: Parameters<T>) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    \n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n/**\n * Throttle function execution\n */\nexport function throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle: boolean;\n  \n  return function(this: any, ...args: Parameters<T>) {\n    if (!inThrottle) {\n      func.apply(this, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\n/**\n * Retry async function with exponential backoff\n */\nexport async function retry<T>(\n  fn: () => Promise<T>,\n  options: {\n    maxAttempts?: number;\n    delay?: number;\n    backoff?: number;\n    onRetry?: (attempt: number, error: Error) => void;\n  } = {}\n): Promise<T> {\n  const {\n    maxAttempts = 3,\n    delay = 1000,\n    backoff = 2,\n    onRetry\n  } = options;\n\n  let lastError: Error;\n\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error as Error;\n      \n      if (attempt === maxAttempts) {\n        throw lastError;\n      }\n\n      const waitTime = delay * Math.pow(backoff, attempt - 1);\n      \n      if (onRetry) {\n        onRetry(attempt, lastError);\n      }\n\n      await new Promise(resolve => setTimeout(resolve, waitTime));\n    }\n  }\n\n  throw lastError!;\n}\n\n/**\n * Batch array into chunks\n */\nexport function chunk<T>(array: T[], size: number): T[][] {\n  const chunks: T[][] = [];\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n/**\n * Deep clone object\n */\nexport function deepClone<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (obj instanceof Date) return new Date(obj.getTime()) as any;\n  if (obj instanceof Array) return obj.map(item => deepClone(item)) as any;\n  \n  const clonedObj = {} as T;\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      clonedObj[key] = deepClone(obj[key]);\n    }\n  }\n  return clonedObj;\n}\n\n/**\n * Format file size\n */\nexport function formatFileSize(bytes: number): string {\n  if (bytes === 0) return '0 Bytes';\n\n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\n\n/**\n * Generate unique ID\n */\nexport function generateId(prefix: string = ''): string {\n  const timestamp = Date.now().toString(36);\n  const randomStr = Math.random().toString(36).substr(2, 9);\n  return prefix ? `${prefix}-${timestamp}-${randomStr}` : `${timestamp}-${randomStr}`;\n}\n\n/**\n * Safe JSON parse\n */\nexport function safeJsonParse<T = any>(json: string, defaultValue: T): T {\n  try {\n    return JSON.parse(json);\n  } catch {\n    return defaultValue;\n  }\n}\n\n/**\n * Check if running on server\n */\nexport const isServer = typeof window === 'undefined';\n\n/**\n * Check if running on client\n */\nexport const isClient = !isServer;\n\n/**\n * Format phone number\n */\nexport function formatPhoneNumber(phone: string): string {\n  const cleaned = phone.replace(/\\D/g, '');\n  \n  if (cleaned.length === 11) {\n    return cleaned.replace(/(\\d{3})(\\d{4})(\\d{4})/, '$1-$2-$3');\n  } else if (cleaned.length === 10) {\n    return cleaned.replace(/(\\d{3})(\\d{3})(\\d{4})/, '$1-$2-$3');\n  }\n  \n  return phone;\n}\n\n/**\n * Validate email\n */\nexport function isValidEmail(email: string): boolean {\n  const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return re.test(email);\n}\n\n/**\n * Truncate text\n */\nexport function truncate(text: string, maxLength: number, suffix: string = '...'): string {\n  if (text.length <= maxLength) return text;\n  return text.substring(0, maxLength - suffix.length) + suffix;\n}\n\n/**\n * Remove duplicates from array\n */\nexport function uniqueBy<T, K extends keyof T>(array: T[], key: K): T[] {\n  const seen = new Set();\n  return array.filter(item => {\n    const k = item[key];\n    return seen.has(k) ? false : seen.add(k);\n  });\n}\n\n/**\n * Group array by key\n */\nexport function groupBy<T, K extends keyof T>(array: T[], key: K): Record<string, T[]> {\n  return array.reduce((groups, item) => {\n    const group = String(item[key]);\n    if (!groups[group]) {\n      groups[group] = [];\n    }\n    groups[group].push(item);\n    return groups;\n  }, {} as Record<string, T[]>);\n}\n\n/**\n * Sort array by multiple keys\n */\nexport function sortBy<T>(\n  array: T[],\n  keys: Array<{ key: keyof T; order: 'asc' | 'desc' }>\n): T[] {\n  return [...array].sort((a, b) => {\n    for (const { key, order } of keys) {\n      if (a[key] < b[key]) return order === 'asc' ? -1 : 1;\n      if (a[key] > b[key]) return order === 'asc' ? 1 : -1;\n    }\n    return 0;\n  });\n}\n\n/**\n * 날짜 문자열을 한국어 형식으로 포맷팅합니다.\n * @param dateStr - 변환할 날짜 문자열\n * @returns 포맷된 날짜 문자열 (YYYY.MM.DD 형식)\n */\nexport function formatDate(dateStr?: string | null): string {\n  if (!dateStr) return '-';\n  \n  try {\n    const date = new Date(dateStr);\n    if (isNaN(date.getTime())) return '-';\n    \n    return date.toLocaleDateString('ko-KR', {\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n    });\n  } catch {\n    return '-';\n  }\n}\n\n/**\n * Format date and time for Korean locale\n */\nexport function formatDateTime(dateStr?: string | null): string {\n  if (!dateStr) return '-';\n  \n  try {\n    const date = new Date(dateStr);\n    if (isNaN(date.getTime())) return '-';\n    \n    return date.toLocaleString('ko-KR');\n  } catch {\n    return '-';\n  }\n}\n\n/**\n * Format date as MM-DD format\n */\nexport function formatDateShort(dateStr?: string | null): string {\n  if (!dateStr) return '-';\n  \n  try {\n    const date = new Date(dateStr);\n    if (isNaN(date.getTime())) return '-';\n    \n    return `${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;\n  } catch {\n    return '-';\n  }\n}\n\n/**\n * Calculate relative time (e.g., \"2시간 전\", \"3일 전\")\n */\nexport function formatRelativeTime(dateStr?: string | null): string {\n  if (!dateStr) return '-';\n  \n  try {\n    const date = new Date(dateStr);\n    const now = new Date();\n    const diffMs = now.getTime() - date.getTime();\n    \n    const diffMinutes = Math.floor(diffMs / (1000 * 60));\n    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));\n    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));\n    \n    if (diffMinutes < 60) {\n      return diffMinutes < 1 ? '방금 전' : `${diffMinutes}분 전`;\n    } else if (diffHours < 24) {\n      return `${diffHours}시간 전`;\n    } else if (diffDays < 7) {\n      return `${diffDays}일 전`;\n    } else {\n      return formatDate(dateStr);\n    }\n  } catch {\n    return '-';\n  }\n}"],"names":["formatDate","dateStr","date","formatDateShort"],"mappings":"AA0OO,SAASA,EAAWC,EAAiC,CAC1D,GAAI,CAACA,EAAS,MAAO,IAErB,GAAI,CACF,MAAMC,EAAO,IAAI,KAAKD,CAAO,EAC7B,OAAI,MAAMC,EAAK,QAAA,CAAS,EAAU,IAE3BA,EAAK,mBAAmB,QAAS,CACtC,KAAM,UACN,MAAO,UACP,IAAK,SAAA,CACN,CACH,MAAQ,CACN,MAAO,GACT,CACF,CAqBO,SAASC,EAAgBF,EAAiC,CAC/D,GAAI,CAACA,EAAS,MAAO,IAErB,GAAI,CACF,MAAMC,EAAO,IAAI,KAAKD,CAAO,EAC7B,OAAI,MAAMC,EAAK,QAAA,CAAS,EAAU,IAE3B,GAAG,OAAOA,EAAK,SAAA,EAAa,CAAC,EAAE,SAAS,EAAG,GAAG,CAAC,IAAI,OAAOA,EAAK,QAAA,CAAS,EAAE,SAAS,EAAG,GAAG,CAAC,EACnG,MAAQ,CACN,MAAO,GACT,CACF"}
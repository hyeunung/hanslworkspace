# 상세모달 딜레이 원인 분석

## 질문
"발주번호만 대조해서 데이터 가져오면 그만인데 왜 오래 걸리는가?"

## 답변

### 1. 데이터 가져오기는 빠름
- `findPurchaseInMemory(purchaseId)`: 메모리에서 발주번호로 검색 → **즉시 반환**
- `setPurchase(purchaseData)`: 상태 설정 → **즉시 완료**

### 2. 문제: 데이터 가져온 후 칼럼 너비 계산이 동기적으로 실행됨

**실행 순서**:
1. `setPurchase` 호출 (Line 645)
2. `purchase` 상태 변경
3. `useEffect` 트리거 (Line 824-829)
4. **`calculateOptimalColumnWidths()` 동기 실행** ← 여기서 딜레이 발생
5. 모든 아이템 순회하면서 칼럼 너비 계산
6. `setColumnWidths` 호출
7. 모달 렌더링 완료

### 3. 칼럼 너비 계산이 블로킹되는 이유

**Line 714-767**: 모든 아이템을 순회하면서 각 칼럼의 최대 길이 계산
```typescript
items.forEach(item => {
  // 각 칼럼별로 cellValue 계산
  // 한글/영문 혼합 텍스트 길이 계산
  const adjustedLength = cellValue.split('').reduce((acc, char) => {
    return acc + (/[가-힣]/.test(char) ? 1.5 : 1)
  }, 0)
})
```

**계산량** (아이템 10개, done 탭 기준):
- 11개 칼럼 × 10개 아이템 = 110회 계산
- 각 계산마다: 문자열 split + reduce + 정규식 테스트
- 총 연산: 약 1,000회 이상

### 4. 왜 다른 탭은 빠른가?

- 승인대기: 7칼럼 × 10아이템 = 70회 계산
- 구매현황: 8칼럼 × 10아이템 = 80회 계산
- 입고현황: 8칼럼 × 10아이템 = 80회 계산
- **전체항목: 11칼럼 × 10아이템 = 110회 계산** (약 57% 더 많음)

### 5. 결론

**데이터 가져오기는 빠르지만**, 데이터를 가져온 후 **칼럼 너비 계산이 동기적으로 실행**되어 모달 렌더링이 블로킹됩니다.

특히 `done` 탭에서는:
- 추가 4개 칼럼 계산
- 더 많은 연산량
- 동기 실행으로 인한 블로킹

**해결 방안**:
1. 칼럼 너비 계산을 비동기로 처리 (모달 먼저 표시)
2. 기본 칼럼 너비로 먼저 표시하고, 계산 후 업데이트
3. `requestAnimationFrame` 또는 `setTimeout`으로 계산 지연


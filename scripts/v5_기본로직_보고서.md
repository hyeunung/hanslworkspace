# V5 Engine 기본 로직 보고서

## 📋 전체 흐름 개요

```
초기화 → Round 시작 → 보드 수집 → 보드 처리 → 결과 비교 → 데이터셋 저장 → 학습 조건 판단 → 학습 실행 → Round 증가 → 반복
```

---

## 🔧 핵심 함수 및 역할

### 1. **파일 처리 함수들**

#### `fileToText(filePath, checkOnly)`
- **역할**: 파일을 텍스트로 변환
- **지원 형식**: `.txt`, `.csv`, `.cpl`, `.pnp`, `.xlsx`, `.xls`
- **동작**: 
  - 텍스트 파일: 직접 읽기
  - 엑셀 파일: 시트별로 읽어서 탭으로 구분된 텍스트로 변환
  - 빈 행 5개 연속 시 중단

#### `classifyFiles(dirPath)`
- **역할**: 보드 폴더에서 BOM, 좌표, 정답지 파일 찾기
- **파일 식별 규칙**:
  - **정답지**: 파일명에 `(숫자)`, `완료`, `정리` 포함 또는 내용에 `품명`, `Ref`, `SET` 포함
  - **BOM**: 파일명에 `bom`, `part` 포함 또는 내용에 `Footprint`, `Comment`, `Designator`, `품명`, `규격` 포함
  - **좌표**: 파일명에 `좌표`, `pick`, `position` 포함 또는 확장자 `.cpl`, `.pnp` 또는 내용에 `RefDes`, `Location`, `Rotation` 포함
- **반환**: `{ bom, coord, answer }` 또는 `{ warning }`

---

### 2. **AI 추출 함수들**

#### `runStudentModel(modelId, bomText, coordText)`
- **역할**: 학습 중인 모델로 BOM과 좌표 데이터 추출
- **입력**: 
  - `modelId`: 사용할 모델 (초기: `gpt-4o-mini-2024-07-18`, 학습 후: fine-tuned model)
  - `bomText`: BOM 파일 내용 (최대 15000자)
  - `coordText`: 좌표 파일 내용 (최대 15000자)
- **프롬프트**:
  - **BOM**: PCB Footprint로 그룹화, 수량은 Reference 개수와 일치, ItemType 추론
  - **좌표**: RefDes를 키로 하는 좌표 맵
- **반환**: `{ bom: [...], coords: {...} }`

#### `getTrueBOM(answerText)`
- **역할**: 정답지에서 실제 BOM 데이터 추출 (GPT-4o 사용)
- **프롬프트**: 
  - 첫 번째 시트에서 BOM 테이블 찾기
  - `SET` 컬럼을 수량으로 사용
  - `Type`이 비어있으면 위에서 상속
- **반환**: `{ items: [{ itemName, itemType, qty, refs, remark }] }`

#### `getTrueCoords(answerText)`
- **역할**: 정답지에서 실제 좌표 데이터 추출 (GPT-4o 사용)
- **프롬프트**: 
  - `TOP`, `BOTTOM` 시트에서 좌표 추출
- **반환**: `{ "R1": { x, y, rot, side }, ... }`

---

### 3. **비교 및 검증 함수**

#### `compare(studentBOM, studentCoords, trueBOM, trueCoords, round)`
- **역할**: AI 추출 결과와 정답 비교
- **비교 항목**:
  - **품명**: AI가 추출한 항목이 정답에 있는지
  - **SET (수량)**: 수량 일치 여부
  - **종류**: Round 2부터만 검증
  - **좌표X, 좌표Y**: 좌표 값 일치 여부 (차이 0 초과 시 실패)
  - **회전**: 회전 각도 일치 여부
  - **면**: Top/Bottom 일치 여부
- **반환**: `{ diffs: [...], stats: { 항목: { total, fail } } }`

---

### 4. **데이터셋 저장 함수**

#### `saveTrainingData(bomText, coordText, trueBOM, trueCoords)`
- **역할**: 학습용 데이터셋에 정답 데이터 저장
- **형식**: JSONL (각 줄이 하나의 학습 예제)
- **저장 내용**:
  - BOM 추출 예제: `{ messages: [{ role: 'system' }, { role: 'user' }, { role: 'assistant' }] }`
  - 좌표 추출 예제: `{ messages: [{ role: 'system' }, { role: 'user' }, { role: 'assistant' }] }`
- **문제**: 성공/실패와 무관하게 모든 보드의 데이터를 저장

---

### 5. **보드 처리 함수**

#### `processBoard(set, round, currentModel)`
- **역할**: 하나의 보드를 처리하는 전체 파이프라인
- **단계**:
  1. 파일 읽기: BOM, 좌표, 정답지 텍스트로 변환
  2. 병렬 처리:
     - `runStudentModel`: AI로 데이터 추출
     - `getTrueBOM`: 정답지에서 BOM 추출
     - `getTrueCoords`: 정답지에서 좌표 추출
  3. 템플릿 채우기: 추출한 데이터로 엑셀 템플릿 생성
  4. 비교: AI 결과와 정답 비교
  5. 데이터셋 저장: 정답 데이터를 데이터셋에 추가
- **반환**: `{ success, diffs, stats, name, round, generatedFile }`

---

## 🔄 메인 루프 로직 (main 함수)

### 초기화 (Line 554-566)
```javascript
round = 1
currentModel = 'gpt-4o-mini-2024-07-18'
progress = { round: 1, completedBoards: [] }

// 진행 상황 복원
progress = JSON.parse(await fs.readFile(PROGRESS_FILE))
round = progress.round
currentModel = await fs.readFile(LAST_MODEL_FILE) // 있으면
```

### Round 루프 (Line 568-737)

#### 1. Round 시작 (Line 568-575)
```javascript
if (progress.completedBoards.length === 0) {
    await fs.unlink(DATASET_FILE) // 데이터셋 파일 삭제
}
```

#### 2. 보드 수집 (Line 577-600)
```javascript
sets = []
for (year in BASE_PATH) {
    for (board in year) {
        if (board in progress.completedBoards) continue // 이미 처리한 보드 스킵
        files = classifyFiles(boardPath)
        if (files.bom && files.coord && files.answer) {
            sets.push({ name: board, ...files })
        }
    }
}
```

#### 3. 보드 처리 (Line 606-660)
```javascript
for (batch in sets) { // BATCH_SIZE = 5
    results = await Promise.all(batch.map(set => processBoard(set, round, currentModel)))
    
    for (result in results) {
        if (!result.success) failCount++
        progress.completedBoards.push(result.name)
        await fs.writeFile(PROGRESS_FILE, JSON.stringify(progress)) // 즉시 저장
    }
}
```

#### 4. Round 종료 처리 (Line 662-685)
```javascript
// 종료 조건 체크
if (round >= 2 && failCount === 0 && sets.length === 0) {
    break // 완료
}

// Round 증가 및 초기화
progress.round++  // ⚠️ 문제: 학습 전에 증가
progress.completedBoards = []  // ⚠️ 문제: 학습 전에 초기화
await fs.writeFile(PROGRESS_FILE, JSON.stringify(progress))
```

#### 5. 학습 조건 판단 (Line 687-697)
```javascript
datasetExists = await fs.access(DATASET_FILE)

shouldTrain = 
    (round === 1 && datasetExists) ||  // Round 1: 데이터셋 있으면 무조건 학습
    (round >= 2 && failCount > 0 && datasetExists)  // Round 2+: 실패 있고 데이터셋 있으면 학습
```

#### 6. 학습 실행 (Line 699-726)
```javascript
if (shouldTrain) {
    file = await openai.files.create({ file: DATASET_FILE })
    job = await openai.fineTuning.jobs.create({
        training_file: file.id,
        model: currentModel,
        hyperparameters: { n_epochs: 3 }
    })
    
    // 30초마다 상태 확인
    while (true) {
        status = await openai.fineTuning.jobs.retrieve(job.id)
        if (status.status === 'succeeded') {
            currentModel = status.fine_tuned_model
            await fs.writeFile(LAST_MODEL_FILE, currentModel)
            break
        }
        if (status.status === 'failed') {
            // 기본 모델로 계속 진행
            break
        }
        await sleep(30000)
    }
}
```

#### 7. Round 증가 (Line 736)
```javascript
round++  // ⚠️ 문제: 이미 Line 683에서 progress.round++ 했는데 또 증가
```

---

## 📊 검증 항목 상세

### Round 1
- ✅ 품명: AI 추출 항목이 정답에 있는지
- ✅ SET (수량): 수량 일치 여부
- ⏸️ 종류: 검증 안 함 (학습 전)
- ✅ 좌표X, 좌표Y: 좌표 값 일치
- ✅ 회전: 회전 각도 일치
- ✅ 면: Top/Bottom 일치

### Round 2 이상
- ✅ 품명
- ✅ SET (수량)
- ✅ 종류: ItemType 일치 여부 (Round 1에서 학습한 내용 검증)
- ✅ 좌표X, 좌표Y
- ✅ 회전
- ✅ 면

---

## 🎯 학습 전략

### Round 1
- **목적**: 정답지의 품명 → 종류 매핑 학습
- **조건**: 데이터셋이 있으면 무조건 학습 (실패 0건이어도)
- **결과**: ItemType 추론 능력 향상

### Round 2 이상
- **목적**: 실패한 항목에 대한 재학습
- **조건**: 실패가 있고 데이터셋이 있으면 학습
- **결과**: 오류 패턴 개선

---

## ⚙️ 설정값

- **BASE_PATH**: `sample-data/24_25_SOCKET`
- **DATASET_FILE**: `scripts/v5_dataset.jsonl`
- **LAST_MODEL_FILE**: `scripts/v5_last_model.txt`
- **PROGRESS_FILE**: `scripts/v5_progress.json`
- **INITIAL_MODEL**: `gpt-4o-mini-2024-07-18`
- **VERIFIER_MODEL**: `gpt-4o` (정답지 추출용)
- **BATCH_SIZE**: `5` (한 번에 처리할 보드 수)
- **n_epochs**: `3` (학습 에포크 수)

---

## 🔍 주요 특징

1. **자동 반복 학습**: 실패가 있으면 자동으로 재학습
2. **점진적 검증**: Round 1에서는 종류 검증 안 함, Round 2부터 검증
3. **배치 처리**: 5개씩 묶어서 병렬 처리
4. **진행 상황 저장**: 각 보드 처리 후 즉시 저장 (중단 시 복구 가능)
5. **템플릿 생성**: 추출한 데이터로 엑셀 템플릿 자동 생성

---

## ⚠️ 알려진 문제점 (요약)

1. **Round 중복 증가**: Line 683과 736에서 두 번 증가
2. **학습 전 상태 변경**: Round 증가와 completedBoards 초기화가 학습 전에 일어남
3. **데이터셋 누적**: Round 1 시작 시에만 삭제, 이후 계속 누적
4. **실패한 보드 데이터 포함**: 성공/실패와 무관하게 모든 데이터 저장
5. **학습 실패 시 처리 부족**: 재시도 없음, 실패해도 계속 진행

---

이상이 V5 Engine의 기본 로직입니다. 디테일 수정이 필요하시면 알려주세요.
